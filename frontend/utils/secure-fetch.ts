// Utilitaire pour cr√©er un fetch s√©curis√© qui √©vite les interceptions de services tiers

// Utilitaire: cr√©er un fetch natif frais via un iframe (√©vite les r√©f√©rences p√©rim√©es)
function createFreshNativeFetch(): typeof fetch {
  if (typeof window === "undefined" || !window.fetch) {
    return (globalThis.fetch || fetch).bind(globalThis as any);
  }
  try {
    const iframe = document.createElement("iframe");
    iframe.style.display = "none";
    iframe.style.position = "absolute";
    iframe.style.left = "-9999px";
    document.documentElement.appendChild(iframe);

    let iframeFetch: typeof fetch | null = null;
    if (iframe.contentWindow && iframe.contentWindow.fetch) {
      iframeFetch = iframe.contentWindow.fetch.bind(iframe.contentWindow);
    }

    // Nettoyage
    setTimeout(() => {
      try {
        if (iframe.parentNode) iframe.parentNode.removeChild(iframe);
      } catch (e) {
        console.warn("Could not clean up iframe:", e);
      }
    }, 0);

    return (iframeFetch || window.fetch.bind(window)) as typeof fetch;
  } catch (error) {
    console.warn("createFreshNativeFetch failed, using window.fetch:", error);
    return window.fetch.bind(window);
  }
}

// R√©f√©rence initiale (peut devenir invalide si le realm est d√©truit)
const originalFetch = createFreshNativeFetch();

// Interface pour les options √©tendues
interface SecureFetchOptions extends RequestInit {
  useNativeFetch?: boolean;
  maxRetries?: number;
  retryDelay?: number;
  timeout?: number;
}

// Classe pour g√©rer les appels fetch s√©curis√©s
export class SecureFetch {
  private static instance: SecureFetch;

  static getInstance(): SecureFetch {
    if (!SecureFetch.instance) {
      SecureFetch.instance = new SecureFetch();
    }
    return SecureFetch.instance;
  }

  // D√©tecter si fetch a √©t√© modifi√© par un service tiers
  private isNativeFetch(): boolean {
    if (typeof window === "undefined") return true;
    const fetchString = window.fetch.toString();
    const interceptorSignatures = [
      "fullstory",
      "fs.js",
      "sentry",
      "datadog",
      "bugsnag",
      "messageHandler",
    ];
    return !interceptorSignatures.some((s) =>
      fetchString.toLowerCase().includes(s.toLowerCase()),
    );
  }

  // Obtenir un fetch natif frais √† la demande
  private getFreshNativeFetch(): typeof fetch {
    return createFreshNativeFetch();
  }

  // Cr√©er un timeout pour les requ√™tes
  private createTimeoutSignal(timeoutMs: number): AbortSignal {
    const controller = new AbortController();
    setTimeout(() => controller.abort(), timeoutMs);
    return controller.signal;
  }

  // M√©thode principale de fetch s√©curis√©
  async fetch(
    url: string | URL,
    options: SecureFetchOptions = {},
  ): Promise<Response> {
    const {
      useNativeFetch = false,
      maxRetries = 2,
      retryDelay = 1000,
      timeout = 10000,
      ...fetchOptions
    } = options;

    let lastError: Error | null = null;
    // Flags
    let forceWindowFetch = false; // apr√®s realm shutdown
    let forceFreshNative = useNativeFetch; // si on veut √©viter toute interception

    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        console.log(
          `üåê Secure fetch attempt ${attempt + 1}/${maxRetries + 1}: ${url}`,
        );

        // Choisir la fonction fetch √† utiliser avec validation
        let fetchFunction: typeof fetch;

        let usedFreshNative = false;
        try {
          if (forceFreshNative && !forceWindowFetch) {
            // Utiliser un fetch natif fra√Æchement r√©cup√©r√© √† chaque tentative
            fetchFunction = this.getFreshNativeFetch();
            usedFreshNative = true;
          } else if (!this.isNativeFetch() && !forceWindowFetch) {
            // Si window.fetch est intercept√©, utiliser natif frais
            fetchFunction = this.getFreshNativeFetch();
            usedFreshNative = true;
          } else if (!forceWindowFetch) {
            // Sinon tenter la r√©f. initiale
            fetchFunction =
              typeof originalFetch === "function"
                ? (originalFetch as unknown as typeof fetch)
                : window.fetch.bind(window);
          } else {
            // Forcer window.fetch
            fetchFunction = window.fetch.bind(window);
          }
        } catch (scopeError) {
          console.warn(
            "Fetch function selection failed, using window.fetch:",
            scopeError,
          );
          fetchFunction = window.fetch.bind(window);
        }

        // Ajouter un timeout si pas d√©j√† sp√©cifi√©
        const requestOptions: any = { ...fetchOptions };
        // Toujours m√™me-origine
        if (!requestOptions.credentials)
          requestOptions.credentials = "same-origin";
        // √âviter de passer un AbortSignal cross-realm au fetch d'iframe
        if (!requestOptions.signal && timeout > 0 && !usedFreshNative) {
          requestOptions.signal = this.createTimeoutSignal(timeout);
        } else if (usedFreshNative && requestOptions.signal) {
          try {
            delete requestOptions.signal;
          } catch {}
        }

        // Toujours utiliser une URL absolue pour √©viter about:blank avec le fetch d'iframe
        let finalUrl: string | URL = url;
        if (typeof window !== "undefined") {
          if (typeof url === "string") {
            const hasProtocol = /^https?:\/\//i.test(url);
            if (!hasProtocol) {
              finalUrl = url.startsWith("/")
                ? `${window.location.origin}${url}`
                : new URL(url, window.location.href).toString();
            }
          } else if (url instanceof URL) {
            // OK
          }
        }

        const response = await fetchFunction(finalUrl as any, requestOptions);

        // Log du succ√®s
        console.log(`‚úÖ Secure fetch successful: ${url} (${response.status})`);
        return response;
      } catch (error) {
        lastError = error as Error;
        const errorMessage = lastError.message;

        console.warn(
          `‚ö†Ô∏è Secure fetch attempt ${attempt + 1} failed:`,
          errorMessage,
        );

        // V√©rifier si c'est une erreur de port√©e globale
        const isGlobalScopeError = errorMessage.includes(
          "global scope is shutting down",
        );

        // D√©tecter une interception FullStory/Sentry via trace
        const looksIntercepted =
          errorMessage.toLowerCase().includes("messagehandler") ||
          errorMessage.toLowerCase().includes("fs.js") ||
          errorMessage.toLowerCase().includes("fullstory");

        // V√©rifier si c'est une erreur r√©seau temporaire
        const isRetriableError =
          errorMessage.includes("Failed to fetch") ||
          errorMessage.includes("network") ||
          errorMessage.includes("timeout") ||
          errorMessage.includes("AbortError") ||
          isGlobalScopeError ||
          looksIntercepted;

        // Realm shutdown: forcer window.fetch
        if (isGlobalScopeError && attempt < maxRetries) {
          console.log(
            "üîÑ Global scope error detected, forcing window.fetch for next attempt",
          );
          forceWindowFetch = true;
          continue; // retry imm√©diat
        }

        // Interception d√©tect√©e: forcer un fetch natif frais
        if (looksIntercepted && attempt < maxRetries) {
          console.log(
            "üõ°Ô∏è Interception detected, switching to fresh native fetch",
          );
          forceFreshNative = true;
          forceWindowFetch = false;
          continue; // retry imm√©diat
        }

        // Ne pas retry sur la derni√®re tentative ou si l'erreur n'est pas retriable
        if (attempt === maxRetries || !isRetriableError) {
          break;
        }

        // D√©lai avant le retry (d√©lai exponentiel)
        const delay = retryDelay * Math.pow(2, attempt);
        console.log(`‚è≥ Retrying in ${delay}ms...`);
        await new Promise((resolve) => setTimeout(resolve, delay));
      }
    }

    // Si toutes les tentatives ont √©chou√©
    console.error(`‚ùå All secure fetch attempts failed for: ${url}`);

    // Am√©liorer le message d'erreur
    if (lastError) {
      const enhancedError = new Error(
        `Network request failed after ${maxRetries + 1} attempts: ${lastError.message}`,
      );
      enhancedError.name = "SecureFetchError";
      enhancedError.stack = lastError.stack;
      throw enhancedError;
    }

    throw new Error("Network request failed: Unknown error");
  }

  // M√©thodes utilitaires pour les types de requ√™tes courants
  async get(
    url: string | URL,
    options: SecureFetchOptions = {},
  ): Promise<Response> {
    return this.fetch(url, { ...options, method: "GET" });
  }

  async post(
    url: string | URL,
    data?: any,
    options: SecureFetchOptions = {},
  ): Promise<Response> {
    const postOptions: SecureFetchOptions = {
      ...options,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        ...options.headers,
      },
    };

    if (data !== undefined) {
      postOptions.body = typeof data === "string" ? data : JSON.stringify(data);
    }

    return this.fetch(url, postOptions);
  }

  async put(
    url: string | URL,
    data?: any,
    options: SecureFetchOptions = {},
  ): Promise<Response> {
    const putOptions: SecureFetchOptions = {
      ...options,
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        ...options.headers,
      },
    };

    if (data !== undefined) {
      putOptions.body = typeof data === "string" ? data : JSON.stringify(data);
    }

    return this.fetch(url, putOptions);
  }

  async delete(
    url: string | URL,
    options: SecureFetchOptions = {},
  ): Promise<Response> {
    return this.fetch(url, { ...options, method: "DELETE" });
  }

  // Diagnostic pour v√©rifier l'√©tat du fetch
  diagnose(): {
    isNativeFetch: boolean;
    fetchSource: string;
    recommendations: string[];
  } {
    const isNative = this.isNativeFetch();
    const fetchString =
      typeof window !== "undefined"
        ? window.fetch.toString()
        : "N/A (server-side)";

    const recommendations: string[] = [];

    if (!isNative) {
      recommendations.push(
        "Fetch has been intercepted by a third-party service",
      );
      recommendations.push(
        "Consider using useNativeFetch: true for critical requests",
      );
      recommendations.push(
        "Check for services like FullStory, Sentry, or DataDog",
      );
    }

    return {
      isNativeFetch: isNative,
      fetchSource:
        fetchString.substring(0, 200) + (fetchString.length > 200 ? "..." : ""),
      recommendations,
    };
  }
}

// Instance singleton pour l'exportation
export const secureFetch = SecureFetch.getInstance();

// Export par d√©faut pour une utilisation simple
export default secureFetch;

// Fonction utilitaire pour remplacer window.fetch dans les cas critiques
export function createFetchPolyfill(): typeof fetch {
  return secureFetch.fetch.bind(secureFetch) as unknown as typeof fetch;
}

// Hook pour diagnostiquer les probl√®mes de fetch
export function useFetchDiagnostics() {
  return secureFetch.diagnose();
}
